**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1

F(n) = F(n - 1) + F(n - 2)，其中 n > 1

给定 `n` ，请计算 `F(n)` 。

**示例 1：**

**输入：**n = 2
**输出：**1
**解释：**F(2) = F(1) + F(0) = 1 + 0 = 1

**示例 2：**

**输入：**n = 3
**输出：**2
**解释：**F(3) = F(2) + F(1) = 1 + 1 = 2

**示例 3：**

**输入：**n = 4
**输出：**3
**解释：**F(4) = F(3) + F(2) = 2 + 1 = 3

**提示：**

- `0 <= n <= 30`

## 思路

斐波那契数列是一个经典示例，它的每个数都是前两个数的和，定义如下：

- `F(0) = 0, F(1) = 1`
- 对于 `n > 1`, `F(n) = F(n-1) + F(n-2)`

如果使用简单的递归来计算 `F(n)`，比如计算 `F(5)`，我们会得到如下的递归树：

```
                 F(5)
               /     \
            F(4)      F(3)
           /   \      /   \
        F(3)  F(2)  F(2)  F(1)
       /   \
    F(2)   F(1)
   /   \
F(1)   F(0)
```

在这个递归树中，`F(2)` 被计算了三次，`F(3)` 被计算了两次，说明存在大量的重复计算。

### 解决重叠子问题

动态规划通过两种主要方式解决重叠子问题：

- **记忆化递归（Top-Down）**：这种方法仍然使用递归框架，但是会将每个子问题的结果存储起来（通常在一个数组或哈希表中），在计算之前先检查结果是否已经被计算过，从而避免重复计算。
- **迭代法（Bottom-Up）**：这种方法使用循环而非递归，从最基本的子问题开始，逐步构建出更大问题的解。因为它是按照顺序计算每个子问题的，所以每个子问题只被计算一次。

让我们以斐波那契数列为例，展示如何使用动态规划避免重复计算：

**记忆化递归示例：**

```java
public int fib(int N) {
    if (N <= 1) {
        return N;
    }
    int[] memo = new int[N + 1];
    memo[0] = 0;
    memo[1] = 1;
    return fib(N, memo);
}

private int fib(int N, int[] memo) {
    if (memo[N] != 0) {
        return memo[N];
    }
    memo[N] = fib(N - 1, memo) + fib(N - 2, memo);
    return memo[N];
}
```

**迭代法示例：**

```java
public int fib(int N) {
    if (N <= 1) {
        return N;
    }
    int[] dp = new int[N + 1];
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= N; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[N];
}
```

在这两种方法中，我们都只计算每个子问题一次，极大地提高了效率。

## 实践中识别重叠子问题

在实际问题中，识别重叠子问题的关键是注意到递归解法中的重复计算。如果你发现通过递归解决问题时存在大量的重复计算，那么这个问题很可能可以通过动态规划来高效解决。
