---
tags:
  - 归档/📦/贪心
  - 归档/📦/排序
  - 归档/📦/计算几何
  - 归档/📦/叉积
  - 归档/📦/蓝桥杯
---

## 问题描述

最近暑期特训算法班的同学们表现出色，他们的老师肖恩决定给他们分发糖果。肖恩购买了 *n* 个不同种类的糖果，用小写的阿拉伯字母表示。每个糖果必须分发给一个同学，并且每个同学至少要分到一个糖果。同学们的开心程度定义为他们所分到的糖果组成的字符串的字典序。肖恩希望同学们的开心程度相差尽量小，因此他要找到一种方案，使得所有糖果组成的字符串中字典序最大的字符串尽可能小。请输出能够实现字典序最小可能的 `max(s[1],s[2],s[3],…,s[x])` 。

## 输入描述

第一行输入两个整数 *n* 和 *x* ，分别表示有 *n* 个糖果，*x* 个同学。

第二行输入一个长度为 *n* 的字符串 *S* ，`S[i]` 表示第 *i* 个糖果的种类。

数据保证：

> $1≤n≤10^6, 1≤x≤n, S[i]∈[ 'a' , 'z' ]$

## 输出描述

输出一个字符串，为所有糖果组成的字符串中字典序最大的字符串最小的可能值。

## 样例输入

```
6 2
caabdc
```

## 样例输出

```
abccd
```

## 说明

一个最优分配方案是一个同学拿到 *abccd* ，一个同学拿到 *a* 。

## 解题思路

这个题目的核心是如何找到字典序最大的字符串最小的可能值。我们可以从贪心算法和字典序的性质入手：

1. **贪心思想**：贪心算法是一种选择最优子结构的算法。在每一步，我们都根据当前的情况做出一个在当前看来是最好的选择，而不考虑未来的情况。贪心算法通常适用于需要在多个可能的解决方案中做出选择的问题。
2. **字典序的性质**：字典序是字符串的一种排序方式，它基于字符串中每个字符的 ASCII 码或 Unicode 码点值来比较。字典序满足传递性，即如果 *a < b* 且 *b < c* ，那么 *a < c* 。此外，字典序还满足单调性，即如果我们将字符串 *a* 和 *b* 看作是实数轴上的点，那么当 *a < b* 时，对于任何字符串 *c* ，如果 *a < c < b* ，那么 *a* 在实数轴上的位置一定在 *c* 的左边。

基于以上两点，我们可以推断：如果我们将糖果分配给同学，使得每个同学分到的糖果组成的字符串的字典序尽可能接近，那么最终的字典序最大值就会是最小的。

具体算法步骤如下：

1. **排序**：首先根据字典序对糖果进行升序排序。
2. **贪心分配**：从排序后的糖果序列中，依次将糖果分配给每个同学。如果某个同学已经分到了糖果，那么我们选择下一个字典序较大的糖果分配给下一个同学。
3. **构造结果**：将每个同学分到的糖果组成的字符串按照字典序从小到大排列，连接成一个字符串作为结果输出。

%% 以下是 Java 代码实现：

```java
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        int x = scan.nextInt();
        char[] s = scan.next().toCharArray();
        Arrays.sort(s);

        // 贪心分配糖果
        char[] candy = new char[x];
        int idx = 0;
        for (int i = 0; i < n; i++) {
            if (idx == x) break;
            candy[idx++] = s[i];
            if (idx < x) {
                candy[idx] = s[i];
            }
        }

        // 构造结果
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < x; i++) {
            result.append(candy[i]);
        }
        System.out.println(result);

        scan.close();
    }
}
```

通过这种贪心的方法，我们可以保证每个同学分到的糖果组成的字符串的字典序尽可能接近，从而得到字典序最大值最小的结果。 %%
