#回收站/知识盒/计算机科学/Git

## 基础篇

> 循序渐进地介绍 Git 主要命令

### 1. Git Commit（提交）

> [!quote] 引用
> 把提交记录看作是项目的快照。提交记录非常轻量，可以快速地在这些提交记录之间切换！

### 2. Git Branch（分支）

> [!quote] 引用
> 早建分支！多用分支！
>
> 这是因为即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。
>
> 在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：" 我想基于这个提交以及它所有的 parent 提交进行新的工作。"

- 创建分支：`git branch <branchName>`;
- 切换分支：`git checkout(switch) <branch>` ;

### 3. Git Merge

> [!quote] 引用
> 我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。
>
> 咱们先来看一下第一种方法 —— `git merge`。在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个 parent 节点。翻译成自然语言相当于：" 我要把这两个 parent 节点本身及它们所有的祖先都包含进来。"

### 4. Git Rebase

> [!quote] 引用
> Rebase 实际上就是取出一系列的提交记录，" 复制 " 它们，然后在另外一个地方逐个的放下去。
>
> Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。

> 惊到我了，我之前和朋友同学以前使用仓库的时候，都是 git clone 下来，然后在 git 那个分支上去，原来可以直接 reset 到目标分支后。

## 高级篇

> 介绍 Git 超棒的特性。

### 1. 分离 HEAD

> [!quote] 引用
>  HEAD 是一个对当前所在分支的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。
>
> HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。
>
> HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。

#### 相对引用 ^ 与 ~

- ^ 向当前节点向上移动一个节点。
- ~<num> 向上移动 num 个节点。

> [!quote] 引用
 > `-f` 则容许我们将分支强制移动到那个位置。

#### 撤销变更

> [!quote] 引用
> 在 Git 里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。
>
> 主要有两种方法用来撤销变更 —— 一是 `git reset`，还有就是 `git revert`。接下来咱们逐个进行讲解。

> [!warning] 注意
> 我们只需要注意，reset 主要用于本地，而 revert 用于远程。

## 移动提交记录

> 自由修改提交树

### 整理提交记录

> [!quote] 引用
> 系列的第一个命令是 `git cherry-pick`, 命令形式为:
>
> - `git cherry-pick <提交号>…`
>
> 如果你想将一些提交复制到当前所在的位置（`HEAD`）下面的话， Cherry-pick 是最直接的方式了。我个人非常喜欢 `cherry-pick`，因为它特别简单。

### 交互式的 Rebase

> [!quote] 引用
> 当你知道你所需要的提交记录（**并且**还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。
>
> 但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了

> [!important] 重要
> 交互式 rebase 指的是使用带参数 `--interactive` 的 rebase 命令, 简写为 `-i`

> [!quote] 引用
> 当 rebase UI 界面打开时, 你能做 3 件事:
>
> - 调整提交记录的顺序（通过鼠标拖放来完成）
> - 删除你不想要的提交（通过切换 `pick` 的状态来完成，关闭就意味着你不想要这个提交记录）
> - 合并提交。 遗憾的是由于某种逻辑的原因，我们的课程不支持此功能，因此我不会详细介绍这个操作。简而言之，它允许你把多个提交记录合并成一个。

> [!question] 问题
> 这样做的目的是什么？也就是移动整理提交记录的作用是什么？我想不出来。

## 杂项

> Git 技术、技巧与贴士大集合

### 只提取一个提交记录

> 主要应用 `git rebase -i` 与 `git rebase`。

### 提交的技巧#1

> 应用 `git commit --amend`

> [!question] 问题
> `--amend` 的作用是什么？我没理解到。

### Git Tag

> [!quote] 引用
> 有没有什么可以 _ 永远 _ 指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？
> Git 的 tag 就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。
>
> 更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。

> [!question] 问题
> 没有理解到 tag 的作用是什么。

### Git Describe

> 由于标签在代码库中起着 " 锚点 " 的作用，Git 还为此专门设计了一个命令用来**描述**离你最近的锚点（也就是标签），它就是 `git describe`！
>
> Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 `git bisect`（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。

### 多次 Rebase

## 高级话题

> 真正的勇士

## 远程仓库

> [!quote] 引用
> 远程仓库并不复杂, 在如今的云计算盛行的世界很容易把远程仓库想象成一个富有魔力的东西, 但实际上它们只是你的仓库在另个一台计算机上的拷贝。你可以通过因特网与这台计算机通信 —— 也就是增加或是获取提交记录
>
> 话虽如此, 远程仓库却有一系列强大的特性
>
> - 首先也是最重要的的点, 远程仓库是一个强大的备份。本地仓库也有恢复文件到指定版本的能力, 但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据, 你仍可以通过远程仓库拿回你丢失的数据。
>
> - 还有就是, 远程让代码社交化了! 既然你的项目被托管到别的地方了, 你的朋友可以更容易地为你的项目做贡献 (或者拉取最新的变更)
>
>
> 现在用网站来对远程仓库进行可视化操作变得越发流行了 (像 [GitHub](https://github.com/)), 但远程仓库**永远**是这些工具的顶梁柱, 因此理解其概念非常的重要!

### 远程分支

> 使用 `git clone` 我们获得了一个本地仓库，其中本地仓库中的分支类似 `o/main`，这是远程分支。

> [!quote] 引用
> 既然你已经看过 `git clone` 命令了，咱们深入地看一下发生了什么。
>
> 你可能注意到的第一个事就是在我们的本地仓库多了一个名为 `o/main` 的分支, 这种类型的分支就叫**远程**分支。由于远程分支的特性导致其拥有一些特殊属性。
>
> 远程分支反映了远程仓库 (在你上次和它通信时) 的**状态**。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.
>
> 远程分支有一个特别的属性，在你切换到远程分支时，自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。

> [!question] 问题
> ### 为什么有 `o/`？
>
> > [!quote] 引用
> > 你可能想问这些远程分支的前面的 `o/` 是什么意思呢？好吧, 远程分支有一个命名规范 —— 它们的格式是:
> >
> > - `<remote name>/<branch name>`
> >
> > 因此，如果你看到一个名为 `o/main` 的分支，那么这个分支就叫 `main`，远程仓库的名称就是 `o`。
> >
> > 大多数的开发人员会将它们主要的远程仓库命名为 `origin`，并不是 `o`。这是因为当你用 `git clone` 某个仓库时，Git 已经帮你把远程仓库的名称设置为 `origin` 了
> >
> > 不过 `origin` 对于我们的 UI 来说太长了，因此不得不使用简写 `o` :) 但是要记住, 当你使用真正的 Git 时, 你的远程仓库默认为 `origin`!

### Git Fetch

> [!quote] 引用
> Git 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。
>
> 本节课我们将学习如何从远程仓库获取数据 —— 命令如其名，它就是 `git fetch`。

> 笑死我了，情书，我记得我好行在 Git 上传过类似的。

> [!quote] #### git fetch 会做什么？
> `git fetch` 完成了仅有的但是很重要的两步:
>
> - 从远程仓库下载本地仓库中缺失的提交记录
> - 更新远程分支指针 (如 `o/main`)
>
> `git fetch` 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。
>
> 如果你还记得上一节课程中我们说过的，远程分支反映了远程仓库在你**最后一次与它通信时**的状态，`git fetch` 就是你与远程仓库通信的方式了！希望我说的够明白了，你已经了解 `git fetch` 与远程分支之间的关系了吧。
>
> `git fetch` 通常通过互联网（使用 `http://` 或 `git://` 协议) 与远程仓库通信。

> [!quote] git fetch 不会的事情
> `git fetch` 并不会改变你本地仓库的状态。它不会更新你的 `main` 分支，也不会修改你磁盘上的文件。
>
> 理解这一点很重要，因为许多开发人员误以为执行了 `git fetch` 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是**并没有**修改你本地的文件。我们在后面的课程中将会讲解能完成该操作的命令 :D
>
> 所以, 你可以将 `git fetch` 的理解为单纯的下载操作。

### 偏离的工作

> [!warning] 注意
>
> > [!quote] 引用
> > 假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目**旧版**的代码，与远程仓库最新的代码不匹配了。
> >
> > 这种情况下, `git push` 就不知道该如何操作了。如果你执行 `git push`，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？
> >
> > 因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 `push` 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。

### 合并特性分支

> [!quote] 引用
> 在大型项目中开发人员通常会在（从 `main` 上分出来的）特性分支上工作，工作完成后只做一次集成。这跟前面课程的描述很相像（把 side 分支推送到远程仓库），不过本节我们会深入一些.
>
> 但是有些开发人员只在 main 上做 push、pull —— 这样的话 main 总是最新的，始终与远程分支 (o/main) 保持一致。
>
> 对于接下来这个工作流，我们集成了两个步骤：
>
> - 将特性分支集成到 `main` 上
> - 推送并更新远程分支

> [!question] 为什么不使用 Merge 合并分支呢？
>
> > [!quote] 引用
> > 关于 rebase 的优缺点：
> >
> > 优点:
> >
> > - Rebase 使你的提交树变得很干净, 所有的提交都在一条线上
> >
> > 缺点:
> >
> > - Rebase 修改了提交树的历史
> >
> > 比如, 提交 C1 可以被 rebase 到 C3 之后。这看起来 C1 中的工作是在 C3 之后进行的，但实际上是在 C3 之前。
> >
> > 一些开发人员喜欢保留提交历史，因此更偏爱 merge。而其他人（比如我自己）可能更喜欢干净的提交树，于是偏爱 rebase。仁者见仁，智者见智。 :D

> 我更喜欢 Meger 一些，这个更直观，并且保留了历史记录。

### 远程追踪

> [!quote] 引用
> 直接了当地讲，`main` 和 `o/main` 的关联关系就是由分支的 "remote tracking" 属性决定的。`main` 被设定为跟踪 `o/main` —— 这意味着为 `main` 分支指定了推送的目的地以及拉取后合并的目标。
>
> 你可能想知道 `main` 分支上这个属性是怎么被设定的，你并没有用任何命令指定过这个属性呀！好吧, 当你克隆仓库的时候, Git 就自动帮你把这个属性设置好了。
>
> 当你克隆时, Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 `o/main`）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 `main`。
>
> 克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是 " 空白 " 的），但是可以查看远程仓库中所有的分支（如果你好奇心很强的话）。这样做对于本地仓库和远程仓库来说，都是最佳选择。
>
> 这也解释了为什么会在克隆的时候会看到下面的输出：
>
> ```
> local branch "main" set to track remote branch "o/main"
> ```
> >
> > [!question] 自己可以指定这个属性吗？
> > 当然可以啦！你可以让任意分支跟踪 `o/main`, 然后该分支会像 `main` 分支一样得到隐含的 push 目的地以及 merge 的目标。 这意味着你可以在分支 `totallyNotMain` 上执行 `git push`，将工作推送到远程仓库的 `main` 分支上。
> >
> > #### 第一种就是通过远程分支切换到一个新的分支，执行:
> >
> > `git checkout -b totallyNotMain o/main`
> >
> > 就可以创建一个名为 `totallyNotMain` 的分支，它跟踪远程分支 `o/main`。
> > #### 第二种方法
> >
> > 另一种设置远程追踪分支的方法就是使用：`git branch -u` 命令，执行：
> >
> > `git branch -u o/main foo`
> >
> > 这样 `foo` 就会跟踪 `o/main` 了。如果当前就在 foo 分支上, 还可以省略 foo：
> >
> > `git branch -u o/main`

### Git Push 的参数

> [!question] push 的主要的参数是什么？
> ## push 的语法
>
> > [!quote] 引用
> > 首先来看 `git push`。在远程跟踪课程中，你已经学到了 Git 是通过当前所在分支的属性来确定远程仓库以及要 push 的目的地的。这是未指定参数时的行为，我们可以为 push 指定参数，语法是：
> >
> > `git push <remote> <place>`
> > `<place>` 参数是什么意思呢？我们稍后会深入其中的细节, 先看看例子, 这个命令是:
> >
> > `git push origin main`
> >
> > 把这个命令翻译过来就是：
> >
> > _切到本地仓库中的 "main" 分支，获取所有的提交，再到远程仓库 "origin" 中找到 "main" 分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。_
> > ### `<place>` 参数详解
> > 当为 git push 指定 place 参数为 `main` 时，我们同时指定了提交记录的来源和去向。
> >
> > 你可能想问 —— 如果来源和去向分支的名称不同呢？比如你想把本地的 `foo` 分支推送到远程仓库中的 `bar` 分支。
> >
> > 哎，很遗憾 Git 做不到…… 开个玩笑，别当真！当然是可以的啦 :) Git 拥有超强的灵活性（有点过于灵活了）
> >
> > 要同时为源和目的地指定 `<place>` 的话，只需要用冒号 `:` 将二者连起来就可以了：
> >
> > `git push origin <source>:<destination>`
> >
> > 这个参数实际的值是个 refspec，"refspec" 是一个自造的词，意思是 Git 能识别的位置（比如分支 `foo` 或者 `HEAD~1`）

### Git Fetch 的参数

> [!quote] 引用
> `git fetch` 的参数和 `git push` 极其相似。他们的概念是相同的，只是方向相反罢了（因为现在你是下载，而非上传）
> #### `<place>` 参数
>
> 如果你像如下命令这样为 git fetch 设置 的话：
>
> `git fetch origin foo`
>
> Git 会到远程仓库的 `foo` 分支上，然后获取所有本地不存在的提交，放到本地的 `o/foo` 上。
> " 如果我们指定 `<source>:<destination>` 会发生什么呢？"
>
> 如果你觉得直接更新本地分支很爽，那你就用冒号分隔的 refspec 吧。不过，你不能在当前切换的分支上干这个事，但是其它分支是可以的。
>
> 这里有一点是需要注意的 —— `source` 现在指的是远程仓库中的位置，而 `<destination>` 才是要放置提交的本地仓库的位置。它与 git push 刚好相反，这是可以讲的通的，因为我们在往相反的方向传送数据。
>
> > [!warning] 注意
> > 理论上虽然行的通，但开发人员很少这么做。我在这里介绍它主要是为了从概念上说明 `fetch` 和 `push` 的相似性，只是方向相反罢了。

### Git Pull

> [!quote] 引用
> 既然你已经掌握关于 `git fetch` 和 `git push` 参数的方方面面了，关于 git pull 几乎没有什么可以讲的了 :)
>
> 因为 git pull 到头来就是 fetch 后跟 merge 的缩写。你可以理解为用同样的参数执行 git fetch，然后再 merge 你所抓取到的提交记录。
