## 问题描述

小青蛙住在一条河边, 它想到河对岸的学校去学习。小青蛙打算经过河里的石头跳到对岸。

河里的石头排成了一条直线, 小青蛙每次跳跃必须落在一块石头或者岸上。 不过, 每块石头有一个高度，每次小青蛙从一块石头起跳，这块石头的高度就 会下降 1 ，当石头的高度下降到 0 时小青蛙不能再跳到这块石头上（某次跳跃 后使石头高度下降到 0 是允许的）。

小青蛙一共需要去学校上 $x$ 天课, 所以它需要往返 $2x$ 次。当小青蛙具有 一个跳跃能力 $y$ 时, 它能跳不超过 $y$ 的距离。

请问小青蛙的跳跃能力至少是多少才能用这些石头上完 $x$ 次课。

## 输入格式

输入的第一行包含两个整数 $n,x$, 分别表示河的宽度和小青蛙需要去学校的 天数。请注意 $2x$ 才是实际过河的次数。

第二行包含 $n−1$ 个非负整数 $H_1,H_2,⋯,H_{n−1}$，其中 $H_i > 0$ 表示在河中与 小青蛙的家相距 $i$ 的地方有一块高度为 $H_i$ 的石头, $H_i = 0$ 表示这个位置没有石 头。

## 输出格式

输出一行, 包含一个整数, 表示小青蛙需要的最低跳跃能力。

## 样例输入

```
5 1
1 0 1 0
```

## 样例输出

```
4
```

## 样例说明

由于只有两块高度为 $1$ 的石头，所以往返只能各用一块。第 $1$ 块石头和对岸的距离为 $4$，如果小青蛙的跳跃能力为 $3$ 则无法满足要求。所以小青蛙最少需要 $4$ 的跳跃能力。

## 相关标签

#回收站/知识盒/📦/贪心

## 解题思路

%%

这是一道典型的贪心算法题目。我们可以从后往前遍历石头序列，贪心地选择当前能跳的最远距离，并更新答案。

具体来说，我们维护一个变量 `max_jump` 表示目前需要的最大跳跃距离，初始值为 0。然后从后往前遍历石头序列，如果当前石头的高度大于等于 `max_jump`，那么更新 `max_jump` 为当前石头的位置加上它的高度。这样，`max_jump` 就表示了目前需要的最大跳跃距离。

最后，输出 `max_jump + 1` 作为答案，因为青蛙的跳跃能力至少需要大于等于最大跳跃距离。

## 代码实现

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        int x = scan.nextInt();
        int[] stones = new int[n - 1];
        for (int i = 0; i < n - 1; i++) {
            stones[i] = scan.nextInt();
        }
        scan.close();

        int max_jump = 0;
        for (int i = n - 2; i >= 0; i--) {
            if (stones[i] >= max_jump) {
                max_jump = i + stones[i];
            }
        }

        System.out.println(max_jump + 1);
    }
}
```

## 代码解释

1. 我们使用 `Scanner` 类来读取输入，读取两个整数 `n` 和 `x`，并读取 `n-1` 个非负整数存储在数组 `stones` 中。
2. 初始化 `max_jump` 为 0。
3. 遍历石头序列的逆序，如果当前石头的高度大于等于 `max_jump`，那么更新 `max_jump` 为当前石头的位置加上它的高度。
4. 最后输出 `max_jump + 1` 作为答案。

## 复杂度分析

- 时间复杂度：O(n)，其中 n 是河的宽度。
- 空间复杂度：O(n)，我们使用了长度为 n-1 的数组来存储石头高度。

## 总结

这是一道典型的贪心算法题目，通过从后往前遍历石头序列，贪心地选择当前能跳的最远距离，并更新答案，最终得到小青蛙需要的最低跳跃能力。 %%
